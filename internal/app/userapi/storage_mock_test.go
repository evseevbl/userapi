package userapi

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i github.com/evseevbl/userapi/internal/app/userapi.storage -o ./internal/app/userapi/storage_mock_test.go

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/evseevbl/userapi/internal/pkg/store"
	"github.com/gojuno/minimock/v3"
)

// StorageMock implements storage
type StorageMock struct {
	t minimock.Tester

	funcGetUserByLogin          func(ctx context.Context, login string) (up1 *store.User, err error)
	inspectFuncGetUserByLogin   func(ctx context.Context, login string)
	afterGetUserByLoginCounter  uint64
	beforeGetUserByLoginCounter uint64
	GetUserByLoginMock          mStorageMockGetUserByLogin

	funcSaveUser          func(ctx context.Context, user *store.User) (i1 int64, err error)
	inspectFuncSaveUser   func(ctx context.Context, user *store.User)
	afterSaveUserCounter  uint64
	beforeSaveUserCounter uint64
	SaveUserMock          mStorageMockSaveUser
}

// NewStorageMock returns a mock for storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetUserByLoginMock = mStorageMockGetUserByLogin{mock: m}
	m.GetUserByLoginMock.callArgs = []*StorageMockGetUserByLoginParams{}

	m.SaveUserMock = mStorageMockSaveUser{mock: m}
	m.SaveUserMock.callArgs = []*StorageMockSaveUserParams{}

	return m
}

type mStorageMockGetUserByLogin struct {
	mock               *StorageMock
	defaultExpectation *StorageMockGetUserByLoginExpectation
	expectations       []*StorageMockGetUserByLoginExpectation

	callArgs []*StorageMockGetUserByLoginParams
	mutex    sync.RWMutex
}

// StorageMockGetUserByLoginExpectation specifies expectation struct of the storage.GetUserByLogin
type StorageMockGetUserByLoginExpectation struct {
	mock    *StorageMock
	params  *StorageMockGetUserByLoginParams
	results *StorageMockGetUserByLoginResults
	Counter uint64
}

// StorageMockGetUserByLoginParams contains parameters of the storage.GetUserByLogin
type StorageMockGetUserByLoginParams struct {
	ctx   context.Context
	login string
}

// StorageMockGetUserByLoginResults contains results of the storage.GetUserByLogin
type StorageMockGetUserByLoginResults struct {
	up1 *store.User
	err error
}

// Expect sets up expected params for storage.GetUserByLogin
func (mmGetUserByLogin *mStorageMockGetUserByLogin) Expect(ctx context.Context, login string) *mStorageMockGetUserByLogin {
	if mmGetUserByLogin.mock.funcGetUserByLogin != nil {
		mmGetUserByLogin.mock.t.Fatalf("StorageMock.GetUserByLogin mock is already set by Set")
	}

	if mmGetUserByLogin.defaultExpectation == nil {
		mmGetUserByLogin.defaultExpectation = &StorageMockGetUserByLoginExpectation{}
	}

	mmGetUserByLogin.defaultExpectation.params = &StorageMockGetUserByLoginParams{ctx, login}
	for _, e := range mmGetUserByLogin.expectations {
		if minimock.Equal(e.params, mmGetUserByLogin.defaultExpectation.params) {
			mmGetUserByLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUserByLogin.defaultExpectation.params)
		}
	}

	return mmGetUserByLogin
}

// Inspect accepts an inspector function that has same arguments as the storage.GetUserByLogin
func (mmGetUserByLogin *mStorageMockGetUserByLogin) Inspect(f func(ctx context.Context, login string)) *mStorageMockGetUserByLogin {
	if mmGetUserByLogin.mock.inspectFuncGetUserByLogin != nil {
		mmGetUserByLogin.mock.t.Fatalf("Inspect function is already set for StorageMock.GetUserByLogin")
	}

	mmGetUserByLogin.mock.inspectFuncGetUserByLogin = f

	return mmGetUserByLogin
}

// Return sets up results that will be returned by storage.GetUserByLogin
func (mmGetUserByLogin *mStorageMockGetUserByLogin) Return(up1 *store.User, err error) *StorageMock {
	if mmGetUserByLogin.mock.funcGetUserByLogin != nil {
		mmGetUserByLogin.mock.t.Fatalf("StorageMock.GetUserByLogin mock is already set by Set")
	}

	if mmGetUserByLogin.defaultExpectation == nil {
		mmGetUserByLogin.defaultExpectation = &StorageMockGetUserByLoginExpectation{mock: mmGetUserByLogin.mock}
	}
	mmGetUserByLogin.defaultExpectation.results = &StorageMockGetUserByLoginResults{up1, err}
	return mmGetUserByLogin.mock
}

//Set uses given function f to mock the storage.GetUserByLogin method
func (mmGetUserByLogin *mStorageMockGetUserByLogin) Set(f func(ctx context.Context, login string) (up1 *store.User, err error)) *StorageMock {
	if mmGetUserByLogin.defaultExpectation != nil {
		mmGetUserByLogin.mock.t.Fatalf("Default expectation is already set for the storage.GetUserByLogin method")
	}

	if len(mmGetUserByLogin.expectations) > 0 {
		mmGetUserByLogin.mock.t.Fatalf("Some expectations are already set for the storage.GetUserByLogin method")
	}

	mmGetUserByLogin.mock.funcGetUserByLogin = f
	return mmGetUserByLogin.mock
}

// When sets expectation for the storage.GetUserByLogin which will trigger the result defined by the following
// Then helper
func (mmGetUserByLogin *mStorageMockGetUserByLogin) When(ctx context.Context, login string) *StorageMockGetUserByLoginExpectation {
	if mmGetUserByLogin.mock.funcGetUserByLogin != nil {
		mmGetUserByLogin.mock.t.Fatalf("StorageMock.GetUserByLogin mock is already set by Set")
	}

	expectation := &StorageMockGetUserByLoginExpectation{
		mock:   mmGetUserByLogin.mock,
		params: &StorageMockGetUserByLoginParams{ctx, login},
	}
	mmGetUserByLogin.expectations = append(mmGetUserByLogin.expectations, expectation)
	return expectation
}

// Then sets up storage.GetUserByLogin return parameters for the expectation previously defined by the When method
func (e *StorageMockGetUserByLoginExpectation) Then(up1 *store.User, err error) *StorageMock {
	e.results = &StorageMockGetUserByLoginResults{up1, err}
	return e.mock
}

// GetUserByLogin implements storage
func (mmGetUserByLogin *StorageMock) GetUserByLogin(ctx context.Context, login string) (up1 *store.User, err error) {
	mm_atomic.AddUint64(&mmGetUserByLogin.beforeGetUserByLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUserByLogin.afterGetUserByLoginCounter, 1)

	if mmGetUserByLogin.inspectFuncGetUserByLogin != nil {
		mmGetUserByLogin.inspectFuncGetUserByLogin(ctx, login)
	}

	mm_params := &StorageMockGetUserByLoginParams{ctx, login}

	// Record call args
	mmGetUserByLogin.GetUserByLoginMock.mutex.Lock()
	mmGetUserByLogin.GetUserByLoginMock.callArgs = append(mmGetUserByLogin.GetUserByLoginMock.callArgs, mm_params)
	mmGetUserByLogin.GetUserByLoginMock.mutex.Unlock()

	for _, e := range mmGetUserByLogin.GetUserByLoginMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUserByLogin.GetUserByLoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUserByLogin.GetUserByLoginMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUserByLogin.GetUserByLoginMock.defaultExpectation.params
		mm_got := StorageMockGetUserByLoginParams{ctx, login}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUserByLogin.t.Errorf("StorageMock.GetUserByLogin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUserByLogin.GetUserByLoginMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUserByLogin.t.Fatal("No results are set for the StorageMock.GetUserByLogin")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUserByLogin.funcGetUserByLogin != nil {
		return mmGetUserByLogin.funcGetUserByLogin(ctx, login)
	}
	mmGetUserByLogin.t.Fatalf("Unexpected call to StorageMock.GetUserByLogin. %v %v", ctx, login)
	return
}

// GetUserByLoginAfterCounter returns a count of finished StorageMock.GetUserByLogin invocations
func (mmGetUserByLogin *StorageMock) GetUserByLoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByLogin.afterGetUserByLoginCounter)
}

// GetUserByLoginBeforeCounter returns a count of StorageMock.GetUserByLogin invocations
func (mmGetUserByLogin *StorageMock) GetUserByLoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUserByLogin.beforeGetUserByLoginCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetUserByLogin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUserByLogin *mStorageMockGetUserByLogin) Calls() []*StorageMockGetUserByLoginParams {
	mmGetUserByLogin.mutex.RLock()

	argCopy := make([]*StorageMockGetUserByLoginParams, len(mmGetUserByLogin.callArgs))
	copy(argCopy, mmGetUserByLogin.callArgs)

	mmGetUserByLogin.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserByLoginDone returns true if the count of the GetUserByLogin invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetUserByLoginDone() bool {
	for _, e := range m.GetUserByLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByLoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByLoginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByLogin != nil && mm_atomic.LoadUint64(&m.afterGetUserByLoginCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUserByLoginInspect logs each unmet expectation
func (m *StorageMock) MinimockGetUserByLoginInspect() {
	for _, e := range m.GetUserByLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetUserByLogin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserByLoginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUserByLoginCounter) < 1 {
		if m.GetUserByLoginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.GetUserByLogin")
		} else {
			m.t.Errorf("Expected call to StorageMock.GetUserByLogin with params: %#v", *m.GetUserByLoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUserByLogin != nil && mm_atomic.LoadUint64(&m.afterGetUserByLoginCounter) < 1 {
		m.t.Error("Expected call to StorageMock.GetUserByLogin")
	}
}

type mStorageMockSaveUser struct {
	mock               *StorageMock
	defaultExpectation *StorageMockSaveUserExpectation
	expectations       []*StorageMockSaveUserExpectation

	callArgs []*StorageMockSaveUserParams
	mutex    sync.RWMutex
}

// StorageMockSaveUserExpectation specifies expectation struct of the storage.SaveUser
type StorageMockSaveUserExpectation struct {
	mock    *StorageMock
	params  *StorageMockSaveUserParams
	results *StorageMockSaveUserResults
	Counter uint64
}

// StorageMockSaveUserParams contains parameters of the storage.SaveUser
type StorageMockSaveUserParams struct {
	ctx  context.Context
	user *store.User
}

// StorageMockSaveUserResults contains results of the storage.SaveUser
type StorageMockSaveUserResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for storage.SaveUser
func (mmSaveUser *mStorageMockSaveUser) Expect(ctx context.Context, user *store.User) *mStorageMockSaveUser {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("StorageMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &StorageMockSaveUserExpectation{}
	}

	mmSaveUser.defaultExpectation.params = &StorageMockSaveUserParams{ctx, user}
	for _, e := range mmSaveUser.expectations {
		if minimock.Equal(e.params, mmSaveUser.defaultExpectation.params) {
			mmSaveUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveUser.defaultExpectation.params)
		}
	}

	return mmSaveUser
}

// Inspect accepts an inspector function that has same arguments as the storage.SaveUser
func (mmSaveUser *mStorageMockSaveUser) Inspect(f func(ctx context.Context, user *store.User)) *mStorageMockSaveUser {
	if mmSaveUser.mock.inspectFuncSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("Inspect function is already set for StorageMock.SaveUser")
	}

	mmSaveUser.mock.inspectFuncSaveUser = f

	return mmSaveUser
}

// Return sets up results that will be returned by storage.SaveUser
func (mmSaveUser *mStorageMockSaveUser) Return(i1 int64, err error) *StorageMock {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("StorageMock.SaveUser mock is already set by Set")
	}

	if mmSaveUser.defaultExpectation == nil {
		mmSaveUser.defaultExpectation = &StorageMockSaveUserExpectation{mock: mmSaveUser.mock}
	}
	mmSaveUser.defaultExpectation.results = &StorageMockSaveUserResults{i1, err}
	return mmSaveUser.mock
}

//Set uses given function f to mock the storage.SaveUser method
func (mmSaveUser *mStorageMockSaveUser) Set(f func(ctx context.Context, user *store.User) (i1 int64, err error)) *StorageMock {
	if mmSaveUser.defaultExpectation != nil {
		mmSaveUser.mock.t.Fatalf("Default expectation is already set for the storage.SaveUser method")
	}

	if len(mmSaveUser.expectations) > 0 {
		mmSaveUser.mock.t.Fatalf("Some expectations are already set for the storage.SaveUser method")
	}

	mmSaveUser.mock.funcSaveUser = f
	return mmSaveUser.mock
}

// When sets expectation for the storage.SaveUser which will trigger the result defined by the following
// Then helper
func (mmSaveUser *mStorageMockSaveUser) When(ctx context.Context, user *store.User) *StorageMockSaveUserExpectation {
	if mmSaveUser.mock.funcSaveUser != nil {
		mmSaveUser.mock.t.Fatalf("StorageMock.SaveUser mock is already set by Set")
	}

	expectation := &StorageMockSaveUserExpectation{
		mock:   mmSaveUser.mock,
		params: &StorageMockSaveUserParams{ctx, user},
	}
	mmSaveUser.expectations = append(mmSaveUser.expectations, expectation)
	return expectation
}

// Then sets up storage.SaveUser return parameters for the expectation previously defined by the When method
func (e *StorageMockSaveUserExpectation) Then(i1 int64, err error) *StorageMock {
	e.results = &StorageMockSaveUserResults{i1, err}
	return e.mock
}

// SaveUser implements storage
func (mmSaveUser *StorageMock) SaveUser(ctx context.Context, user *store.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSaveUser.beforeSaveUserCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveUser.afterSaveUserCounter, 1)

	if mmSaveUser.inspectFuncSaveUser != nil {
		mmSaveUser.inspectFuncSaveUser(ctx, user)
	}

	mm_params := &StorageMockSaveUserParams{ctx, user}

	// Record call args
	mmSaveUser.SaveUserMock.mutex.Lock()
	mmSaveUser.SaveUserMock.callArgs = append(mmSaveUser.SaveUserMock.callArgs, mm_params)
	mmSaveUser.SaveUserMock.mutex.Unlock()

	for _, e := range mmSaveUser.SaveUserMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSaveUser.SaveUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveUser.SaveUserMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveUser.SaveUserMock.defaultExpectation.params
		mm_got := StorageMockSaveUserParams{ctx, user}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveUser.t.Errorf("StorageMock.SaveUser got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveUser.SaveUserMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveUser.t.Fatal("No results are set for the StorageMock.SaveUser")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSaveUser.funcSaveUser != nil {
		return mmSaveUser.funcSaveUser(ctx, user)
	}
	mmSaveUser.t.Fatalf("Unexpected call to StorageMock.SaveUser. %v %v", ctx, user)
	return
}

// SaveUserAfterCounter returns a count of finished StorageMock.SaveUser invocations
func (mmSaveUser *StorageMock) SaveUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUser.afterSaveUserCounter)
}

// SaveUserBeforeCounter returns a count of StorageMock.SaveUser invocations
func (mmSaveUser *StorageMock) SaveUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveUser.beforeSaveUserCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SaveUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveUser *mStorageMockSaveUser) Calls() []*StorageMockSaveUserParams {
	mmSaveUser.mutex.RLock()

	argCopy := make([]*StorageMockSaveUserParams, len(mmSaveUser.callArgs))
	copy(argCopy, mmSaveUser.callArgs)

	mmSaveUser.mutex.RUnlock()

	return argCopy
}

// MinimockSaveUserDone returns true if the count of the SaveUser invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSaveUserDone() bool {
	for _, e := range m.SaveUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUser != nil && mm_atomic.LoadUint64(&m.afterSaveUserCounter) < 1 {
		return false
	}
	return true
}

// MinimockSaveUserInspect logs each unmet expectation
func (m *StorageMock) MinimockSaveUserInspect() {
	for _, e := range m.SaveUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SaveUser with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SaveUserMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSaveUserCounter) < 1 {
		if m.SaveUserMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to StorageMock.SaveUser")
		} else {
			m.t.Errorf("Expected call to StorageMock.SaveUser with params: %#v", *m.SaveUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveUser != nil && mm_atomic.LoadUint64(&m.afterSaveUserCounter) < 1 {
		m.t.Error("Expected call to StorageMock.SaveUser")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetUserByLoginInspect()

		m.MinimockSaveUserInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetUserByLoginDone() &&
		m.MinimockSaveUserDone()
}
